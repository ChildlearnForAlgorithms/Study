import heapq

def solve(A, k): # return k-th smallest key, 1 <= k <= n
	for i in range(k-1): # k-1번 반복
		A[0] = A[-1] # 최상위 노드를 제일 마지막 노드와 변경
		A = A[:len(A) - 1] # 마지막 노드를 없앰
		m = 0 # 시작 노드
		
		while 2 * m + 1 < len(A): # A가 리프노드가 아닐 때
			L, R = 2 * m + 1, 2 * m + 2 # 왼쪽 자식 노드와 오른쪽 자식 노드의 위치
			child = L # 자식 노드 중 작은 값의 위치 저장할 변수
				
			if R < len(A): # R이 len(A)보다 작을 때 (자식 노드가 2개 일 때)
				if A[R] < A[L]: # 오른쪽 자식 노드가 왼쪽 자식 노드보다 작으면
					child = R # child에 오른쪽 자식 노드의 위치 저장
			
			if A[m] > A[child]: # 자식 노드 중 작은 값이 부모 노드보다 작으면
				A[m], A[child] = A[child], A[m]
				m = child
				# 부모 노드와 자식 노드의 값을 바꾼 뒤, m에 child를 저장
			else: # 부모 노드가 더 작으면 반복문 탈출
				break
	return A[0] # 최상위 노드 반환
k = int(input())
A = [int(x) for x in input().split()]
heapq.heapify(A) # A is now a min-heap
print(solve(A, k))
# 주석
'''
코드 설명
k-1번의 최상위 노드를 pop연산한 뒤, 최상위 노드를 반환하면 k번째로 작은 수가 반환된다.

수행시간 분석
먼저, while문의 수행시간은 자식 노드를 따라 내려가는 것이기 때문에
최악이 경우 h(힙의 높이) * 14(연산 횟수)의 시간이 필요하다.
힙의 높이는 A가 n개 일ㄷ 때, 1 + 2 + 2^2 + ~ + 2^(h - 1) = 2^h - 1 = n 이므로
2^h <= n이 되고 양변에 log를 취하면 h <= log(n)이 된다.
이렇게 while문의 시간 복잡도는 O(log(n))이고
while문을 감싼 for문은 k-1번 실행을 하기 때문에
최악의 경우는 k가 n일 때 가장 많이 반복이 된다.
결국 solve함수의 수행시간은 (n - 1)*(14 * log(n) + 3) 
= n * log(n) * 14 + 3*n - 14 * log(n) - 3이고 
시간 복잡도는 O(nlog(n))이다.
'''
'''
비교
장점
QUICK, MoM 알고리즘에서 피벗값보다 작은 값들과 큰 값들을 저장할 배열을 만드는 것과 달리 HEAP 알고리즘에서는 다른 배열을 사용하지 않고 주어진 배열을 이용하기 때문에 메모리 절약이 가능하다.
SORT 알고리즘에서는 몇 번째의 값이 필요한지에 상관없이 정렬을 하기 위해 항상 O(nlog(n))의 수행을 해야하지만 HEAP 알고리즘에서는 k가 작을 수록 더 적은 연산을 할 수 있어 최대 O(nlog(n))의 수행시간을 보장한다.

단점
QUICK, MoM 알고리즘과 비교했을 때 HEAP을 이용한 알고리즘은 k에 따라 수행시간의 차이가 생기기 때문에 k가 큰 수일 수록 수행시간이 커져 QUICK, MoM보다 수행시간이 느릴 수 있다는 것이 단점이다.
SORT 알고리즘은 한 번만 실행을 하면 다음 k번째 작은 수를 찾을 때 함수를 호출하지 않아도 되지만, HEAP 알고리즘은 작은 수를 찾을 때마다 함수를 호출해야되는 것이 단점이다.

'''