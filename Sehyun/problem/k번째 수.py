import heapq  # heapq 모듈을 불러옴.
from sys import stdin  # 실행 속도를 빠르게 하기 위해 sys 모듈의 stdin을 불러옴.

A = list(map(int, stdin.readline().split()))  # 리스트 생성.

ans = 0  # m[i]의 값을 담을 변수를 초기화해줌.
max_heap = []  # max-heap을 생성해줌.
min_heap = []  # min-heap을 생성해줌.

for idx, val in enumerate(A,start=1):  # 파이썬의 enumerate() 함수를 이용해 인덱스와 원소를 동시에 접근하면서 루프를 돌림. 이때 가장 작은 원소를 1번째로 작다고 정의하기로 했으니까 시작 인덱스를 1로 변경.
    if min_heap and (idx != 1 and idx % 3 == 1):  # min-heap이 비어있지 않고 인덱스가 1이 아니고(시작 원소니까) 3으로 나눈 나머지가 1일 때
        val2 = heapq.heappop(min_heap)  # heapq.heappush(max_heap,(-heapq.heappop(min_heap),heapq.heappop(min_heap))으로 해주면 최대 힙에 push 할 때 우선 순위에 따라 순서가 바뀌므로 먼저 따로 변수를 생성하여 최소 힙의 원소를 pop 해줌.
        heapq.heappush(max_heap, (-val2, val2))

    heapq.heappush(max_heap, (-val,val))  # heapq 모듈은 최소 힙을 기능만으로 동작하기 때문에 최대 힙으로 활용하려면 힙에 튜플을 원소로 추가하거나 삭제하면, 튜플 내에서 맨 앞에 있는 값을 기준으로 최소 힙이 구성되는 원리를 이용함. 따라서, 최대 힙을 만들려면 각 값에 대한 우선 순위를 구한 후, (우선 순위, 값) 구조의 튜플을 힙에 추가해줌.
    val3=heapq.heappop(max_heap)[1] # 힙에서 값을 읽어올 때는 우선 순위에는 관심이 없으므로 각 튜플에서 인덱스 1에 있는 값을 취함.
    heapq.heappush(min_heap, val3)  # 최대 힙에서 pop 했던 값을 최소 힙에 넣어줌.
    ans += min_heap[0]  # min-heap의 첫 번째 원소를 ans 변수에 저장해줌.

print(ans)  # 답을 출력.

'''
사용한 자료구조 및 알고리즘 분석

max-heap과 min-heap 총 2개의 힙을 이용해 i//3+1번째 작은 수를 찾도록 하였다. heap은 우선순위 큐이므로 pop을 하면 0번째 원소가 삭제되면서 반환되는 성질을 이용하였다.
idx != 1 and idx % 3 == 1 이 아닐 때는 최대 힙에 넣고, 그 다음 최대 힙의 원소를 pop 하여 최소 힙에 넣는다. 이를 idx != 1 and idx % 3 == 1을 만족할 때까지 반복한다. 
반복하면서 최소 힙에는 원소가 계속 저장된다. idx != 1 and idx % 3 == 1을 만족하는 인덱스 값을 만나면 최소 힙의 원소를 pop하여 최대 힙에 넣고, idx != 1 and idx % 3 == 1을 만족하는 인덱스의 val 값을
최소 힙에 넣어서 i//3+1번째로 작은 수를 찾을 수 있도록 하였다. for문이 돌아갈 때마다 최소 힙의 첫 번째 원소를 변수에 저장 후, 최종적으로 그 변수의 값을 출력해 준다.

수행시간 분석

for문 내부의 heappop()과 heappush()는 O(log(n))의 시간 복잡도를 가진다.
이는 힙의 높이(h)가 리스트 원소의 개수가 n개일 때, 2^0+2^1+.......+2^(h-1)+2^(h-2)=2^h-1=n이기 때문에 양변에 로그를 취하여 시간 복잡도를 구해보면 O(log(n))이기 때문이다.
for문은 리스트의 길이만큼 돌아가므로 수행시간은 리스트 원소의 개수에 비례하기 때문에 O(n)의 시간 복잡도를 가진다.
for문은 내부의 heappop() 및 heappush() 및 여러 연산을 감싸고 있기 때문에 이 코드의 수행시간을 표현해보면 T(n)=n*logn+C(C는 상수)이다.
따라서 이 코드의 수행시간을 Big-O로 표기하면 O(nlog(n))이 된다.

'''

'''
import heapq 
#heap을 이용해 문제를 풀기 위해 heapq를 import 한다

hsum=0 #m[i] 값의 합을 구하기 위해 담아두는 변수
S=[] #최대힙 사용-root인 값 (- 부호를 붙여서 젤 작은 값이 중요): - 부호를 붙이는 이유. heapq에서는 최소힙은 제공하지만 최대힙은 제공하지 않는다. 따라서 -를 붙여 정렬이 되었을때 가장 큰 값은 제일 작은 값에 속하게 되고 그 값을 빼어내서 -를 다시 붙이게 되면 최대값을 구할 수 있다. 

M=[] #중간 부분에 저장하는 값은 1개만 올 수 있다. 
L=[] #최소힙 사용 -root인 값( heapq에서 제공, 가장 큰 값이 중요)
nums=list(map(int,input().split()))
#nums에는 입력값들이 차례로 list 형태로 들어가게 된다.

#가장 처음에는 M에 아무것도 없고 S,L에도 값이 들어있지 않게 된다. 아래 부분의 코드가 처음부터 잘 시행될 수 있도록 처음에 들어오는 값은 M에 바로 heappush 해준다. 
heapq.heappush(M,nums[0]) 

#가장 처음에 들어오는 값은 k=n//3+1에 따라 1번째로 작은 값이 바로 되기 때문에 hsum에 바로 더해준다. 
hsum+=nums[0]


#for문을 이용해 배열에 있는 개수만큼 반복해준다. (1부터인 이유: 윗부분 코드에서 첫번째에 대한 실행을 직접 코드로 구현해줬기 때문에 첫번째부터 실행할 필요가 없어진다.)
for n in range(1,len(nums)):
   k=n//3
# M에 오는 값이 n//3+1번째 값이 된다. 그 이전의 값들은 n//3번째까지의 값들이며, S에 있는 개수와 M의 개수의 한계선을 유지해주기 위해서 k값을 for문이 돌 때마다 계산해줘야한다. 

   #값을 집어넣을 때 어디로 집어넣을지에 대한 부분이다.
   if nums[n]>M[0]:  #만약 들어올 값이 for문이 도는 시점에서 M에 들어있는 값보다 크다면 L에 heappush 해준다.
      heapq.heappush(L,nums[n])
   else: #이외의 경우: 특히 들어올 값이 for문이 도는 시점에서 M에 들어있는 값보다 작을 때를 생각해줄 수 있다. 이때에는 S에 값을 heappush해준다. 다만, S에서는 최대힙을 사용하기 때문에 가장 큰 값을 구하는 것만이 중요하다. S에 값이 꽉 찰 경우 (k//3) M으로 옮겨줄 필요가 있다. 최대힙은 heapq에서 제공되지 않기 때문에 -를 붙여서 넣어줘야한다.
      heapq.heappush(S,-nums[n])
      

   # n//3+1번째로 작은 값을 구하는 알고리즘
   
   if len(S)>k: #S에 있는 수의 개수가 k보다 크다면 M의 값을 L로 옮겨주고 (M은 1개여야하기 때문에) S에 있던 값(-가 붙여져 있는 상태)에 -를 다시 붙여 원래의 형태로 M에 heappush를 해준다. 
      i = heapq.heappop(M)
      heapq.heappush(L,i) #heappop을 하면서 heappush를 해야하는 이유는 heappop을 해야 빠진 상태로 heappush 할 수 있기 때문이다. 
      j = -heapq.heappop(S)
      heapq.heappush(M,j)
      hsum+=M[0] #hsum(m[i]값의 합)에 구한 n//3+1 번째로 작은 값을 더해준다.
   
      

   elif len(S)==k: #S에 있는 수의 개수가 k와 같다면 딱 M에 있는 값이 우리가 구하는 n//3+1번째로 작은 수라고 할 수 있다.
      hsum+=M[0] #따라서 바로, hsum(m[i]값의 합)에 구한 n//3+1 번째로 작은 값을 더해준다.

      
   # elif len(S)<k를 생각할 수 있음
   else:  #S에 있는 수의 개수가 k보다 작다면 M의 값을 S로 옮겨주고 (S에서 최대힙의 구조를 만들어 놓을 수 있도록 M의 값에 -를 붙여 넣어준다.) (M은 1개여야하기 때문에 옮겨줘야할 필요가 있다). M이 현재 비어있다. L에 있던 값을 빼어내 (heappop을 할 경우 가장 작은 값이 나온다) 그 값을 M에 heappush해준다. 
      l = -heapq.heappop(M)
      heapq.heappush(S, l)
      m = heapq.heappop(L)
      heapq.heappush(M,m)
      hsum+=M[0] #hsum(m[i]값의 합)에 구한 n//3+1 번째로 작은 값을 더해준다.

   

   

print(hsum) #for문을 다 수행한 마지막 hsum을 구해준다. (m[i] 값의 합)


# 사용한 자료구조와 알고리즘 소개
# heap 구조를 사용하였다. 특히 S라는 배열에서는 M으로 가장 큰 수를 빼서 옮겨주는 과정이 필요하다고 생각하여 최대힙을 사용하였고, L라는 배열에서는 M으로 가장 작은 수를 빼서 옮겨 줘야하는 부분이 필요해서 최소힙을 사용하였다. 가장 처음 값은 M에 넣어주고 그 다음부터는 M보다 큰지 작은지를 판단하여 각각 S와 L에 넣어줬다. 첫번째를 제외하고는 (입력 배열의 개수 n) n//3+1 번째 수를 찾기 위해 S가 가득 차면 (S는 n//3개 들어가야함) M에 있던 것을 L로 옮겨주고 S에 있는 최대값을 M으로 옮겨줬다. S의 개수가 부족하다면 M에 있는 것을 S로 옮겨준 후에 L에 있는 최소값을 M으로 옮겨줬다. 이 알고리즘을 이용해 S의 n//3의 개수를 유지해줄 수 있고, M에 있는 값을 n//3+1 번째로 작은 값으로 얻을 수 있다.

#수행시간 분석
#  변수에 값이 지정되는 부분과 같이 단순 입력을 상수시간 n 이라고 할 수 있다 (무시가능). for문을 돌때 리스트에 있는 개수 만큼의 반복은 리스트 개수와 연관이 있기 때문에 Big-O 를 통해 O(n)의 시간임을 확인할 수 있다. 이후 각 조건문을 통해 heappop, heappush가 수행된다. 예를 들어 [1,4,2,3]이 있을때 리스트가 [1,2,4,3] 리스트로 힙구조의 형식으로 정렬이 되는 것이 heappop()인데, 이는 O(logN)시간이 걸린다. 또한 heappush()의 경우에도 힙에 원소를 추가하며 정렬하므로 같은 방식으로 각각의 시간 복잡도는 O(log(n))이다.  값이 계속 해서 heappop과 heappush를 거친다는 (최악의 상황)상황에서 for문 내부 이러한 조건문이 실행되면 T(n)=logn*n +c 으로 O(nlog(n))이 수행시간임을 알 수 있다. 
'''